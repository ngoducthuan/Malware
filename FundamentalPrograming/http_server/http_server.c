//gcc .\http_server.c -o .\http_server.exe -lws2_32 -lpthread
//Compiler using gcc client.c -o client.exe -lws2_32
#include <stdio.h>
//#include <sys/socket.h> Using for socket function if you work on Linux
#include <winsock2.h> //Using for socket function if you work on Windows
//#include <netinet/in.h> Using for AF_NET on Linux
//#include <ws2tcpip.h>//This header file primarily defines structures and constants related to network addressing, such as struct sockaddr_in for IPv4 addresses.
#include<stdlib.h>
#include<string.h>
//#include <arpa/inet.h> // For inet_ntoa function
#include <pthread.h>
#include <unistd.h>// khai báo cho các hàm read, write, và close.
#include <stdbool.h>

#define MAX_CONNECT 5

//Delete resource
void delete_resource(char *path){
    return TRUE;
}

//Handle get request from client
void handle_get_requests(SOCKET client_socket, struct sockaddr_in client_info){
    //Send response to client
    char *response = "\nHTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n";
                     //"<html><head><title>Simple HTTP Server</title></head>"
                     //"<body><h1>Hello from the HTTP server!</h1></body></html>";

    int bytes_send = send(client_socket, response, strlen(response), 0);
    if(bytes_send == SOCKET_ERROR){
        printf("[-] Error sending response to %s:%d.\n", inet_ntoa(client_info.sin_addr), ntohs(client_info.sin_port));
    }
}
//Handle post from client
void handle_post_requests(SOCKET client_socket, struct sockaddr_in client_info, char message[1024]){
    char *body_start = strstr(message, "\r\n\r\n");//returns a pointer to the first occurrence of the \r\n\r\n substring within the received message string.
    if(body_start != NULL){
        //Move place where start content of body
        body_start += 4;
        //Print message which receive message from client 
        printf("[2] Received  POST body data from %s:%d: %s\n", inet_ntoa(client_info.sin_addr), ntohs(client_info.sin_port), body_start);
        //Send response to client 
        char *response = "HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n";

        int bytes_send = send(client_socket, response, strlen(response), 0);
        if(bytes_send == SOCKET_ERROR){
            printf("[-] Error sending response Oke to client.\n");
        }
    //If body start is NULL
    }else{
        char *response = "\nHTTP/1.1 400 Bad Request2\r\nContent-Length: 0\r\n\r";
        int bytes_send = send(client_socket, response, strlen(response), 0);
        if(bytes_send == SOCKET_ERROR){
            printf("[-] Error sending response Bad Request to client.\n");
        }
    }
}

//Handle PUT request from client
void handle_put_requests(SOCKET client_socket, struct sockaddr_in client_info, char message[1024]){
    //Find the first place started body
    char *start_body = strstr(message, "\r\n\r\n");
    if(start_body != NULL){
        //Move the first place to start body content
        start_body += 4;
        //Print message is sended from client
        printf("[3]Received PUT data from client: %s\n", start_body);
        //Send response to client
        char *response =  "HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n";
        int bytes_send = send(client_socket, response, strlen(response), 0);
        if(bytes_send == SOCKET_ERROR){
            printf("[-] Error to send response to client.\n");
        }
    }else{
        char *response = "\nHTTP/1.1 400 Bad Request1\r\nContent-Length: 0\r\n\r";
        int bytes_send = send(client_socket, message, strlen(message), 0);
        if(bytes_send == SOCKET_ERROR){
            printf("[-] Error to send response to client.\n");
        }
    }
} 
//Handle DELETE request from client
void handle_delete_requests(SOCKET client_socket, struct sockaddr_in client_info, char message[1024]){
    //Find place where start path
    char *start_path = strstr(message, " ");
    if(start_path != NULL){
        //Move start path
        start_path++;
        //Find place where end path
        char *end_path = strstr(start_path, " ");

        if(end_path != NULL){
            //Calculate length of path
            int path_length = end_path - start_path;

            //Allocate memory for the path string
            char *path = (char *)malloc(path_length + 1);
            if(path != NULL){
                //Copy path from the request message
                strncpy(path, start_path, path_length);
                path[path_length] = '\0';

                //Delete operation
                if (delete_resource(path)) {
                    // Send a success response to the client
                    char *response = "HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n";
                    int bytes_sent = send(client_socket, response, strlen(response), 0);
                    if (bytes_sent == SOCKET_ERROR) {
                        printf("[-] Error sending response to client.\n");
                    }
                } else {
                    // Send a failure response to the client
                    char *response = "HTTP/1.1 404 Not Found\r\nContent-Length: 0\r\n\r\n";
                    int bytes_sent = send(client_socket, response, strlen(response), 0);
                    if (bytes_sent == SOCKET_ERROR) {
                        printf("[-] Error sending response to client.\n");
                    }
                }

                 // Free the memory allocated for the path string
                free(path);
            }else{
                printf("[-] Error allocating memory for path.\n");
            }
        }else{
            printf("[-] Error finding end of path.\n");
        }
    }else{
        printf("[-] Error finding start of path.\n");
    }
}

//Handle more request from more client
void *handle_client(void *arg){
    int client_socket = *((int *)arg);
    //Get information IP and port from client
    struct sockaddr_in client_info;
    int client_info_length = sizeof(client_info);
    getpeername(client_socket, (struct sockaddr *)&client_info, &client_info_length);

    char message[1024] = {0};
    int valread;

    while(TRUE){
        // Receive data from client
        valread = recv(client_socket, message, sizeof(message), 0);

        if (valread == SOCKET_ERROR) {
            printf("[-] Error receiving data from %s:%d.\n", inet_ntoa(client_info.sin_addr), ntohs(client_info.sin_port));
            closesocket(client_socket);
            return NULL;
        }
        if(valread > 0) {
            printf("[+] Received request from %s:%d: \n%s\n", inet_ntoa(client_info.sin_addr), ntohs(client_info.sin_port), message);
        } else {
            printf("[-] Received empty message from %s:%d\n", inet_ntoa(client_info.sin_addr), ntohs(client_info.sin_port));
        }

        //Check whether user want to quite
        if (strncmp(message, "quit", 4) == 0) {
            // Send a goodbye message and close the connection
            char *response = "\nGoodbye\n";
            int byte_send = send(client_socket, response, strlen(response), 0);
            if(byte_send == SOCKET_ERROR){
                printf("[-] Error sending response to client2.\n");
            }
            printf("[+] Closing connection with client %s:%d\n", inet_ntoa(client_info.sin_addr), ntohs(client_info.sin_port));
            closesocket(client_socket);
            return NULL;
        }
        else if (strncmp(message, "GET", 3) == 0) {
            //Response GET request from client
            handle_get_requests(client_socket, client_info);
        }else if(strncmp(message, "POST", 4) == 0){
            //Response POST request from client
            handle_post_requests(client_socket, client_info, message);
        }else if(strncmp(message, "PUT", 3) == 0){
            //Response PUT request from client
            handle_put_requests(client_socket, client_info, message);
        }else if(strncmp(message, "DELETE", 6) == 0){
            //Response PUT request from client
            handle_delete_requests(client_socket, client_info, message);
        }else {
            // Send HTTP response for unsupported request
            char *response = "\nHTTP/1.1 400 Bad Request0\r\nContent-Length: 0\r\n\r";
            int byte_send = send(client_socket, response, strlen(response), 0);
            if(byte_send == SOCKET_ERROR){
                printf("[-] Error sending response to client4.\n");
            }
        }
        // Clear the message buffer for the next iteration
        memset(message, 0, sizeof(message));
    }

    // Close the connection with the client
    closesocket(client_socket);
    printf("[+] Closing connection with client %s:%d\n", inet_ntoa(client_info.sin_addr), ntohs(client_info.sin_port));// Close the connection with the client
    return NULL;
}

//Main function
int main(){
    WSADATA wsa;
    int server_socket, client_socket;
    struct sockaddr_in server_addr, client_addr;
    int port = 8080;
    char message[1024];

    //Initialize WinSock
    if(WSAStartup(MAKEWORD(2, 2), &wsa) != 0){
        printf("[-] WSASStartup failed.");
        WSACleanup();
        return 1;
    }

    //Create socket to receive request from user
    //IPPROTO_TCP indicate that the socket will use the TCP protocol
    server_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(server_socket < 0){
        printf("[-] Error creating socket: %d\n", IPPROTO_TCP);
        WSACleanup();
        return 1;
    }else{
        printf("[+] Create socket successful\n");
    }

    //Assign server address struct
    //INADDR_ANY  telling system accept connection on that port from any network interface
    server_addr.sin_family  = AF_INET;
    //server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_addr.s_addr = inet_addr("172.20.10.2");
    server_addr.sin_port = htons(port);

    //Bind socket to address and port
    if(bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == SOCKET_ERROR){
        printf("[-] Bind failed.\n");
        closesocket(server_socket);
        WSACleanup();
        exit(1);
    }else{
        printf("[+] Blind successful.\n");
    }

    //Listen connect from client
    if(listen(server_socket, MAX_CONNECT) == SOCKET_ERROR){
        printf("[-] Listen failed.\n");
        closesocket(server_socket);
        WSACleanup();
    }else{
        printf("[+] Server is listening on port 8080...\n");
        // Lấy thông tin về địa chỉ IP và cổng của máy chủ
        struct sockaddr_in server_info;
        int server_info_length = sizeof(server_info);
        getsockname(server_socket, (struct sockaddr *)&server_info, &server_info_length);
        printf("[+] Server IP address: %s\n", inet_ntoa(server_info.sin_addr));
        printf("[+] Server port: %d\n", ntohs(server_info.sin_port));
    }
    while(TRUE){
        //Accept coming connection from client
        char message[1024] = "";
        int client_addr_size = sizeof(client_addr);
        client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_addr_size);
        if (client_socket == INVALID_SOCKET) {
            printf("[-] Accept failed: %d\n", WSAGetLastError());
            closesocket(server_socket);
            WSACleanup();
            return 1;
        }
        printf("[*] Connection accepted from %s:%d\n", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
        
        //Create new thread to handle the client
        pthread_attr_t attr;
        pthread_attr_init(&attr);
        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
        pthread_t client_thread;
        if(pthread_create(&client_thread, &attr, handle_client, (void *)&client_socket) != 0){
            perror("[-] Thread creation failure.\n");
            closesocket(server_socket);
            WSACleanup();
            return 1;
        }

        // Detach the thread to avoid memory leaks
        // pthread_detach is used to detach a thread
        //Allowing it to run independently without being joined. 
        pthread_detach(client_thread);
    }

    closesocket(server_socket);
    WSACleanup();

    return 0;
}
